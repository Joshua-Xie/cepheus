#!/bin/bash
#
# Copyright 2017, LambdaStack
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# NOTE: AUTOGENERATED FILE. Only modify template version.

# Exit immediately if anything goes wrong!
set -eu

# Create directory for download cache.
CACHE_ISO={{ cache.iso }}
CACHE_PACKAGES={{ cache.packages }}
CACHE_PYTHON={{ cache.python }}
CACHE_LOADER={{ cache.loader }}
CACHE_COOKBOOK={{ cache.cookbook }}
CACHE_GEM={{ cache.gem }}

echo "====> Checking local environment..."

# Check variables before use below...
USER=`id -un`
GROUP=`id -gn`

echo "====> Checking cache: {{ cache.base }}..."

# If set then it will remove the cache directories
if [[ $BOOTSTRAP_REMOVE_PREREQS -ne 0 ]]; then
    sudo rm -rf {{ cache.base }}
fi

echo "====> Creating cache directories..."

# Create the cache directories...
sudo mkdir -p {{ cache.base }}/{{ cache.pxe_boot }}/{$CACHE_ISO,$CACHE_LOADER}
sudo mkdir -p {{ cache.base }}/{$CACHE_PYTHON,$CACHE_PACKAGES,$CACHE_COOKBOOK,$CACHE_GEM}
sudo chown -R $USER:$GROUP {{ cache.base }}

# NB: If your environment can't access the outside world then execute `cache.commands` where you obtain the pre_reqs before
# calling this...
{% if cache.download != True %}
# Execute raw `commands` as-is...
echo "====> Executing raw commands to fill cache..."
{{ cache.commands }}
# NB: If this is present then the template_engine allowed the cache directories to be created and then executed the `commands`
# and exited normally
echo "====> Success in executing commands!"
echo
exit 0
{% endif %}

# download_file wraps the usual behavior of curling a remote URL to a local file
# NOTE: PROXY - Make sure your http_proxy and https_proxy envrionment variables are set correctly if behind a proxy.
download_file() {
  FILE=$1
  URL=$2

  if [[ ! -f {{ cache.base }}/$FILE && ! -f {{ cache.base }}/${FILE}_downloaded ]]; then
    echo $FILE
    echo $URL

    rm -f {{ cache.base }}/$FILE
    curl -L --progress-bar -o {{ cache.base }}/$FILE $URL
    touch {{ cache.base }}/${FILE}_downloaded
  fi
}

# NOTE: PROXY - Make sure your ftp_proxy envrionment variable is set correctly if behind a proxy.
ftp_file() {
  FILE=$1
  URL=$2

  if [[ ! -f {{ cache.base }}/$FILE && ! -f {{ cache.base }}/${FILE}_downloaded ]]; then
    echo $FILE
    echo $URL

    rm -f {{ cache.base }}/$FILE
    wget $URL -O {{ cache.base }}/$FILE
    touch {{ cache.base }}/${FILE}_downloaded
  fi
}

git_clone_or_update() {
  local NAME=$1
  local URL=$2

  echo "====> Git clone or update..."
  if [[ ! -f {{ cache.base }}/${NAME}_downloaded ]]; then
    if [[ ! -d {{ cache.base }}/$NAME ]]; then
      git clone $URL {{ cache.base }}/$NAME || true
    else
      ( cd {{ cache.base }}/$NAME && git pull --ff-only $URL )
    fi
    touch {{ cache.base }}/${NAME}_downloaded
  fi
}

{% if method == "pxe" %}
# Obtain an RHEL 7.2 image to be used for PXE booting in production.
echo "====> Downloading ISO..."
if [[ ! -z $COBBLER_BOOTSTRAP_ISO ]]; then
  if [[ $COBBLER_DOWNLOAD_ISO -eq 1 ]]; then
    # NOTE: the +e is because the hardware  We can change it later...
    set +e
    download_file {{ cache.pxe_boot }}/{{ cache.iso }}/{{ pxe_boot.iso.name }} {{ pxe_boot.iso.url }}
    set -e
  fi
fi

if [[ ! -z $COBBLER_BOOTSTRAP_ISO ]]; then
  download_file {{ cache.pxe_boot }}/{{ cache.loader }}/pxelinux.0 http://cobbler.github.io/loaders/pxelinux.0-3.86
  download_file {{ cache.pxe_boot }}/{{ cache.loader }}/menu.c32 http://cobbler.github.io/loaders/menu.c32-3.86
  download_file {{ cache.pxe_boot }}/{{ cache.loader }}/grub-x86.efi http://cobbler.github.io/loaders/grub-0.97-x86.efi
  download_file {{ cache.pxe_boot }}/{{ cache.loader }}/grub-x86_64.efi http://cobbler.github.io/loaders/grub-0.97-x86_64.efi
fi
{% endif %}

echo "====> Downloading Chef..."
download_file /{{ cache.packages }}/{{ chef_repo.client.package }} https://packages.chef.io/files/stable/chef/{{ chef_repo.client.version }}/el/7/{{ chef_repo.client.package }}
download_file /{{ cache.packages }}/{{ chef_repo.server.package }} https://packages.chef.io/files/stable/chef-server/{{ chef_repo.server.version }}/el/7/{{ chef_repo.server.package }}

# BIRD is a little different
echo "====> Downloading Bird..."
ftp_file /{{ cache.packages }}/{{ adc_repo.bgp.bird.package }} ftp://bird.network.cz/pub/bird/redhat/{{ adc_repo.bgp.bird.package }}

# Most important cookbook
# If set then it will not download but remove from cache and use the development version that should be set in the cepheus/cookbooks directory.
# if [[ $CHEF_CEPHEUS_DEBUG -eq 0 ]]; then
#     echo "===> Downloading ceph-chef..."
#     download_file {{ cache.cookbook }}/ceph-chef-{{ ceph_chef.version }}.tar.gz http://cookbooks.opscode.com/api/v1/cookbooks/ceph-chef/versions/{{ ceph_chef.version }}/download
# else
#   # Remove it so it's not used.
#   echo "===> Removing ceph-chef cache and using *debug* version of Ceph-Chef..."
#   rm -f {{ cache.base }}/{{ cache.cookbook }}/ceph-chef-*
# fi

{%- if ceph_chef.debug %}

# Remove it so it's not used.
echo "====> Removing ceph-chef cache and using *debug* version of Ceph-Chef..."
rm -f {{ cache.base }}/{{ cache.cookbook }}/ceph-chef-*
# Clone to cookbook area
rm -rf $REPO_ROOT/cookbooks/ceph-chef
git clone -b {{ ceph_chef.git.branch }} {{ ceph_chef.git.url }}/{{ ceph_chef.git.repo }} $REPO_ROOT/cookbooks/ceph-chef

{% else %}

echo "====> Downloading ceph-chef..."
download_file {{ cache.cookbook }}/ceph-chef-{{ ceph_chef.version }}.tar.gz http://cookbooks.opscode.com/api/v1/cookbooks/ceph-chef/versions/{{ ceph_chef.version }}/download

{%- endif %}

if [[ $CEPH_DEV_MODE -ne 0 ]]; then
  echo "====> Cloning Ceph..."
  git_clone_or_update git/ceph https://github.com/ceph/ceph.git
fi

# Python
# NB: If this section is empty it means that no python 'pip like' dependency was asked for so the template_engine skipped it.
{%- for item in python %}
download_file /python/{{ item.name }}-{{ item.verion }}.tar.gz {{ item.url }}{%- if item.inline %}{{ item.name }}-{{ item.version }}.tar.gz{%- endif %}
{%- endfor %}

# Cookbooks
{%- for item in cookbooks %}
download_file {{ cache.cookbook }}/{{ item.name }}-{{ item.version }}.tar.gz http://cookbooks.opscode.com/api/v1/cookbooks/{{ item.name }}/versions/{{ item.version }}/download
{%- endfor %}

# Gems
# REQUIRED for ceph-chef cookbook - must be installed before doing 'sudo chef-client' on any node
{%- for item in ceph_chef.gems %}
download_file {{ cache.gem }}/{{ item.name }}-{{ item.version }}.gem https://rubygems.org/downloads/{{ item.name }}-{{ item.version }}.gem
{%- endfor %}

# Pull needed gems for fpm
GEMS=( {{ gems|join(' ') }} )
# mkdir -p {{ cache.base }}/gems
for GEM in ${GEMS[@]}; do
  download_file {{ cache.gem }}/$GEM.gem https://rubygems.global.ssl.fastly.net/gems/$GEM.gem
done

# Pull knife-acl gem. This is ONLY needed if using data bags where the data bag is created with a recipe!
download_file {{ cache.gem }}/knife-acl-{{ chef_repo.knife_acl_version }}.gem https://rubygems.global.ssl.fastly.net/gems/knife-acl-{{ chef_repo.knife_acl_version }}.gem
